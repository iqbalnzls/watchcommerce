package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.75

import (
	"context"

	"github.com/iqbalnzls/watchcommerce/src/delivery/graph/model"
	"github.com/iqbalnzls/watchcommerce/src/dto"
	appContext "github.com/iqbalnzls/watchcommerce/src/shared/app_context"
)

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id int) (resp *model.Product, err error) {
	req := &dto.GetProductRequest{
		ProductID: int64(id),
	}
	appCtx := appContext.ParsingAppContext(ctx)

	if err = r.Resolver.v.Validate(req); err != nil {
		return
	}

	data, err := r.Resolver.productService.Get(appCtx, req)
	if err != nil {
		return
	}

	resp = toProduct(data)
	return
}

// ProductsByBrand is the resolver for the productsByBrand field.
func (r *queryResolver) ProductsByBrand(ctx context.Context, brandID int) (resp []*model.Product, err error) {
	req := toGetProductByBrandIDRequest(brandID)
	appCtx := appContext.ParsingAppContext(ctx)

	if err = r.Resolver.v.Validate(req); err != nil {
		return
	}

	data, err := r.Resolver.productService.GetByBrandID(appCtx, req)
	if err != nil {
		return
	}

	for _, v := range data {
		product := &model.Product{
			ID:       int(v.ID),
			Name:     v.Name,
			BrandID:  int(v.BrandID),
			Price:    int(v.Price),
			Quantity: int(v.Quantity),
		}

		resp = append(resp, product)
	}

	appCtx.Logger.FinishedRequest(resp)

	return
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
